<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602051 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2070"/>
<h1>操作系统（Linux）CFS 任务调度器可调参数功能汇总</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2021/12/28 15:40</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/1/5 17:20</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><font face="Monaco" style="font-size: 10pt;">结论：</font></b></div><div><b><font face="Monaco" style="font-size: 10pt;"><br/></font></b></div><div><font face="Monaco" style="font-size: 10pt;">个人消费类电子设备中，以 Linux 为核心的操作系统，之所以没有 Windows/MacOS 操作的反应速度快。其根本原因是 Linux 内核的 CFS 调度器不能根据用户的操作行为，快速提升对应进程的优先级，进而完成 CPU 的抢占。</font></div></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><font face="Monaco" style="font-size: 10pt;">任务（process/thread/task）调度器的目标：</font></b></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;">个人办公电脑：快速响应用户的各种操作事件，感知无卡顿。如鼠标点击、敲击键盘、触控板、光驱插入光盘、外接移动硬盘等。</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;">线上服务器：最有效的利用服务器的 CPU/MEM/Disk/Network 等系统资源，提高系统整体吞吐。</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(51, 51, 51);"><b><font face="Monaco" style="font-size: 10pt;">what：什么是上下文切换（context switch）</font></b></span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);"><font face="Monaco" style="font-size: 10pt;">操作系统用下一个任务 B（Task-B） 替换正在执行的任务 A（Task-A）。替换的过程中，首先需要保存 Task-A 的任务现场（包括当前正在执行的指令地址 IP，栈帧地址 SP，堆地址，各个寄存器的相关值等等），然后恢复 Task-B 的任务现场，并开始执行 Tasks-B。</font></span></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);"><b><font face="Monaco" style="font-size: 10pt;">cost：任务切换的代价</font></b></span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);"><font face="Monaco" style="font-size: 10pt;">上下文切换是伴随任务切换发生的，这个过程 CPU 所执行的所有指令并不能产出对用户有意义的输出。仅仅是为了让所有 Task 都得到执行的机会。让用户宏观上感觉 Task 是并发（concurrent）执行的。当然，无论现在的个人电脑还</font></span><span style="font-size: 10pt; font-family: Monaco;">是服务器，已经都是多核心 CPU，已经可以做到 Task 在微观上的并行（parallel）。</span></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><b><font face="Monaco" style="font-size: 10pt;">what：什么是任务抢占</font></b></div><div><span style="color: rgb(51, 51, 51);"><font face="Monaco" style="font-size: 10pt;">    </font></span></div><div><span style="color: rgb(51, 51, 51);"><font face="Monaco" style="font-size: 10pt;">指优先级更高的某些任务, 不能等到当前任务执行结束, 需要即刻执行，即剥夺当前 Task 的 CPU.  如操作系统的中断程序，一般都是需要立刻执行的，具有较高的优先级，一般都是以抢占 CPU 的方式得到运行。</font></span></div></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco" style="font-size: 10pt;"><b>why：为什么操作系统提供部分内核参数给用户调整</b></font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;">在操作系统之上运行的各种应用，业务场景是不一的，且对性能的要求亦有区别，如何使各个应用的响应最优，就需要有针对性的调整系统的相关参数.</font></div></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco" style="font-size: 10pt;"><b>CFS 调度器部分参数 /proc/sys/kernel/sched_*</b></font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;">sched_child_runs_first：父进程创建子进程后, 父子进程哪个先得到调度的机会。默认值是 0：表示父进程; 设置为 1：表示子进程.</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;">sched_compat_yield：是否开启 sched_yield 系统调用功能. 默认值是 0, 表示关闭. sched_yield 系统调用是当前 Task 主动让出 CPU, 让更高优先级或是同等优先级的其他 Task 得到调度的机会. 对于某些依赖 sched_yield 系统调用来提高程序间同步效率的程序, 打开该开关对于程序性能有显著改善.</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;">sched_migration_cost_ns：默认值是 500 000ns; 表示一个 Task 在累积运行 500 us 后, 被判定为一个 &quot;hot task&quot;, 执行的时候尽可能减少该 Task 在 CPU/Node 间的迁移，防止 CPU/Node 的 Cache 失效. 实际调优过程中, 如果发现 Task 频繁在 CPUs/Nodes 见迁移, 建议调大该值; 如果等待调度的 Task 较多而 CPU IDLE 又较高, 建议调小该值.</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;"><font><font><font>sched_latency_ns：表示一个 </font>sched_latency_ns 周期内，所有可以运行的 Task，都可以得到一次调度的机会. 每个 Task 所能分得的时间片 = </font>sched_latency_ns * （current_task_weight/total_task_weight）.但是当 sched_latency_ns/sched_min_granularity_ns &lt; total_runnable_task 时，一个调度周期的时间 </font>sched_latency_ns = total_runnable_task * sched_min_granularity_ns</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;">sched_min_granularity_ns：表示一个 Task 被调度后最小的执行时间, 默认是 4 000 000 ns. 这个值的作用要和上面的 sched_latency_ns 配合起来看. </font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;">sched_wakeup_granularity_ns：表示一个被唤醒的 Task，从它被唤醒，到再次得到调度的最大时间间隔. 默认值是 2 500 000 ns</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;"><font>sched_rt_period_us：默认值是 1 000 000 us. 表示每隔 </font>sched_rt_period_us 计算一次 RealTime Task 占用的调度时间.</font></div><div><font face="Monaco" style="font-size: 10pt;">    </font></div><div><font face="Monaco" style="font-size: 10pt;"><font>sched_rt_runtime_us：表示一个 </font>sched_rt_period_us 周期内，RealTime Task 得到 sched_rt_runtime_us 的调度实际.</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt; font-family: Monaco;"><font>sched_nr_migrate：默认值 32. 表示可以在 CPUs/Nodes 间进行迁移的 Task 数目. 调大该值，可以提高 </font>SCHED_OTHER  组 Task 的性能，但这是以增大 RealTime Task 的延迟为代价的.</font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div><div><font face="Monaco" style="font-size: 10pt;"><br/></font></div></div><div><br/></div></span>
</div></body></html> 